package delaunay

import (
	"math"
	"math/rand"
	"testing"
)

func uniform(n int, rnd *rand.Rand) []Point {
	points := make([]Point, n)
	for i := range points {
		x := rnd.Float64()
		y := rnd.Float64()
		points[i] = Point{x, y}
	}
	return points
}

func normal(n int, rnd *rand.Rand) []Point {
	points := make([]Point, n)
	for i := range points {
		x := rnd.NormFloat64()
		y := rnd.NormFloat64()
		points[i] = Point{x, y}
	}
	return points
}

func grid(n int, rnd *rand.Rand) []Point {
	side := int(math.Floor(math.Sqrt(float64(n))))
	n = side * side
	points := make([]Point, 0, n)
	for y := 0; y < side; y++ {
		for x := 0; x < side; x++ {
			p := Point{float64(x), float64(y)}
			points = append(points, p)
		}
	}
	return points
}

func circle(n int, rnd *rand.Rand) []Point {
	points := make([]Point, n)
	for i := range points {
		t := float64(i) / float64(n)
		x := math.Cos(t)
		y := math.Sin(t)
		points[i] = Point{x, y}
	}
	return points
}

func shouldFail(t *testing.T, points []Point) {
	if _, err := Triangulate(points); err == nil {
		t.Fatal("should have failed")
	}
}

func validate(t *testing.T, points []Point) *Triangulation {
	tri, err := Triangulate(points)
	if err != nil {
		t.Fatal(err)
	}

	// verify halfedges
	for i1, i2 := range tri.Halfedges {
		if i1 != -1 && tri.Halfedges[i1] != i2 {
			t.Fatal("invalid halfedge connection")
		}
		if i2 != -1 && tri.Halfedges[i2] != i1 {
			t.Fatal("invalid halfedge connection")
		}
	}

	// compare hulls
	hull1 := tri.ConvexHull
	hull2 := ConvexHull(points)
	if len(hull1) != len(hull2) {
		t.Fatalf("invalid hull: %d != %d", len(hull1), len(hull2))
	}
	ok := false
	for i, p := range hull2 {
		if p == hull1[0] {
			ok = true
			for j := range hull1 {
				if hull1[j] != hull2[(i+j)%len(hull2)] {
					ok = false
					break
				}
			}
			break
		}
	}
	if !ok {
		t.Fatalf("hulls not equal")
	}

	// verify hull area vs sum of triangle areas
	area1 := polygonArea(hull1)
	area2 := tri.area()
	if math.Abs(area1-area2) > eps {
		t.Fatalf("hull area (%f) != triangle areas (%f)", area1, area2)
	}

	return tri
}

func TestCases(t *testing.T) {
	validate(t, []Point{{516, 661}, {369, 793}, {426, 539}, {273, 525}, {204, 694}, {747, 750}, {454, 390}})
	validate(t, []Point{{382, 302}, {382, 328}, {382, 205}, {623, 175}, {382, 188}, {382, 284}, {623, 87}, {623, 341}, {141, 227}})
	validate(t, []Point{{4, 1}, {3.7974166882130675, 2.0837249985614585}, {3.2170267516619773, 3.0210869309396715}, {2.337215067329615, 3.685489874065187}, {1.276805078389906, 3.9872025288851036}, {0.17901102978375127, 3.885476929518457}, {-0.8079039091377689, 3.3940516818407187}, {-1.550651407188842, 2.5792964886320684}, {-1.9489192990517052, 1.5512485534497125}, {-1.9489192990517057, 0.44875144655029087}, {-1.5506514071888438, -0.5792964886320653}, {-0.8079039091377715, -1.394051681840717}, {0.17901102978374794, -1.8854769295184561}, {1.276805078389902, -1.987202528885104}, {2.337215067329611, -1.6854898740651891}, {3.217026751661974, -1.021086930939675}, {3.7974166882130653, -0.08372499856146409}})
	validate(t, []Point{{0, 0}, {0, 0}, {1, 0}, {1, 1}, {1, 0}, {1, 1}})
	// validate(t, []Point{{66.10364838437141, 68.58861247166476}, {146.6807134621004, 121.68071346210043}, {128.86889656046745, 117.26179755904141}, {66.10364838437144, 68.58861247166477}, {169.552139667572, 146.1337765382769}, {126.62939224605088, 181.11140466039208}, {74.43444828023371, 78.63089877952069}, {121.11140466039205, 153.37060775394912}, {98.88859533960789, 186.62939224605086}, {52.66066896814022, 63.178539267712424}, {85.32133793628044, 86.35707853542483}, {129.61570560806462, 173.90180644032262}, {91.52240934977428, 162.34633135269814}, {137.24095128280055, 112.24095128280054}, {93.37060775394912, 158.88859533960792}, {175, 150}, {124.14213562373091, 184.14213562373098}, {96.2082275923272, 94.08325829132899}, {98.88859533960799, 153.37060775394906}, {117.9820069044207, 109.53561780313727}, {116.19447026430383, 108.26704341337691}, {54.32437806124571, 62.30633496599771}, {30.88688965604674, 47.72617975590414}, {107.09511724837395, 101.80943804723313}, {38.892261948632665, 52.59484129908844}, {146.6807134621004, 121.6807134621004}, {95.85786437626908, 155.85786437626902}, {54.3243780612457, 62.306334965997706}, {137.24095128280055, 112.24095128280055}, {161.5295655286077, 140.44033682675382}, {90.3842943919354, 166.09819355967738}, {113.22072967687429, 93.71772249433295}, {77.88291870749715, 74.87088997733181}, {50, 60}, {85.32133793628046, 86.35707853542485}, {41.77377931209348, 55.45235951180829}, {89.66218903062287, 81.15316748299887}, {101.44145935374857, 87.4354449886659}, {124.14213562373097, 155.85786437626905}, {172.41645518465438, 148.16651658265795}, {63.54755862418691, 70.90471902361652}, {150.64267587256094, 132.7141570708497}, {109.99999999999993, 190}, {128.47759065022572, 177.65366864730183}, {90, 169.99999999999994}, {128.47759065022575, 162.3463313526982}, {156.12047564140028, 131.12047564140028}, {90.38429439193538, 173.9018064403225}, {95.85786437626899, 184.1421356237309}, {77.88291870749714, 74.8708899773318}, {139.7557862165142, 124.98797731494555}, {130, 170}, {102.34633135269813, 188.4775906502257}, {41.77377931209348, 55.45235951180828}, {91.52240934977424, 177.6536686473017}, {27.7845238972653, 45.189682598176866}, {126.62939224605091, 158.88859533960797}, {106.09819355967736, 189.6157056080646}, {52.6606689681402, 63.178539267712395}, {74.43444828023368, 78.63089877952068}, {106.09819355967747, 150.38429439193538}, {117.65366864730173, 188.47759065022575}, {125, 100}, {38.892261948632566, 52.59484129908838}, {52.66066896814023, 63.17853926771242}, {129.61570560806462, 166.09819355967744}, {20, 40}, {117.65366864730181, 151.52240934977428}, {161.52956552860766, 140.44033682675382}, {63.54755862418697, 70.90471902361656}, {127.80118910350068, 102.80118910350068}, {89.66218903062284, 81.15316748299885}, {102.34633135269824, 151.52240934977425}, {93.37060775394906, 181.11140466039197}, {113.9018064403225, 189.61570560806462}, {121.111404660392, 186.62939224605094}, {113.90180644032259, 150.38429439193538}, {110.00000000000003, 150}, {165.56023782070014, 140.56023782070014}})
	validate(t, []Point{{63.547558624186912368259072536602616, 70.9047190236165221222108812071383}, {63.547558624186969211677933344617486, 70.904719023616564754775026813149452}, {66.103648384371410884341457858681679, 68.588612471664760050771292299032211}, {77.882918707497154287011653650552034, 74.870889977331813724958919920027256}, {128.47759065022572144698642659932375, 177.65366864730182783205236773937941}})
	validate(t, []Point{{54.324378061245710114235407672822475, 62.306334965997713482011022279039025}, {63.547558624186912368259072536602616, 70.9047190236165221222108812071383}, {63.547558624186969211677933344617486, 70.904719023616564754775026813149452}, {90.384294391935398493842512834817171, 166.09819355967738374602049589157104}, {90, 169.99999999999994315658113919198513}})
	shouldFail(t, []Point{{0, 0}})
	shouldFail(t, []Point{{0, 0}, {0, 0}, {0, 0}})
	shouldFail(t, []Point{{0, 0}, {1, 0}})
	shouldFail(t, []Point{{0, 0}, {1, 0}, {2, 0}, {3, 0}})
}

func TestUniform(t *testing.T) {
	rnd := rand.New(rand.NewSource(99))
	points := uniform(100000, rnd)
	validate(t, points)
}

func TestNormal(t *testing.T) {
	rnd := rand.New(rand.NewSource(99))
	points := normal(100000, rnd)
	validate(t, points)
}

func TestGrid(t *testing.T) {
	rnd := rand.New(rand.NewSource(99))
	points := grid(100000, rnd)
	tri := validate(t, points)

	// additional grid testing
	ts := tri.Triangles
	for i := 0; i < len(ts); i += 3 {
		p0 := points[ts[i+0]]
		p1 := points[ts[i+1]]
		p2 := points[ts[i+2]]
		a := area(p0, p1, p2)
		if a != 1 { // parallelogram area
			t.Fatal("invalid grid triangle area")
		}
	}
}

func TestCircle(t *testing.T) {
	rnd := rand.New(rand.NewSource(99))
	points := circle(10000, rnd)
	validate(t, points)
}

func BenchmarkUniform(b *testing.B) {
	rnd := rand.New(rand.NewSource(99))
	points := uniform(b.N, rnd)
	Triangulate(points)
}

func BenchmarkNormal(b *testing.B) {
	rnd := rand.New(rand.NewSource(99))
	points := normal(b.N, rnd)
	Triangulate(points)
}

func BenchmarkGrid(b *testing.B) {
	rnd := rand.New(rand.NewSource(99))
	points := grid(b.N, rnd)
	Triangulate(points)
}
